import java.util.*;


public class solveMaze {
	
	static Random rand = new Random();
	public static void main(String[] args) {
		
		int row, col;
		
		row = rand.nextInt(20)+2;
		col = rand.nextInt(20)+2;
		int srow = rand.nextInt(row);
		int scol = 0;
		char[][] maze = new char[row][col];
		int erow= rand.nextInt(row);
		int ecol= maze[erow].length-1;
		for (int i = 0; i < maze.length; i++) {
	            for (int j = 0; j < maze[i].length; j++) {
	                maze[i][j] = '#';
	            }
	        }		
		maze[srow][scol]='*';
		System.out.println(row+"  "+col);
		mazeGenerator(maze, row, col);
		
		navigateMaze(maze,srow,scol,erow,ecol);
		
		clearFails(maze);
		
		maze[srow][scol]='&';
		maze[erow][ecol]='$';
		System.out.println("Start = &\n Exit = $");
		for (int i=0;i<maze.length;i++) {
			for (int j=0; j<maze[i].length;j++) {
				System.out.print(maze[i][j]+" ");
				}
			System.out.print("\n");
			}
	}
	
	public static void mazeGenerator(char[][] m,int r,int c) {
		
		int row, col;
		for( int i=1; i<=r*c*1.25; i++) {
			row =rand.nextInt(r);
			col =rand.nextInt(c);
			
			if(m[row][col]=='#') {
				m[row][col]= '.';
			}

		}
;
	}
	public static void navigateMaze(char[][] maze, int rs, int cs, int re, int ce) {

		LinkedStack<Integer> X = new LinkedStack<>();
		LinkedStack<Integer> Y = new LinkedStack<>();
		
		X.push(cs);
		Y.push(rs);

		maze[rs][cs] = '$';
		maze[re][ce] = '*';
		
		String dir = "";
		maze[Y.peek()][X.peek()] = '#';
		boolean found = false;
		while (!found) {
			blankScreen();
			//System.out.println("Exit is at '*'\nPosition : " + X.peek() + " " + Y.peek());
			if( (Y.peek() + 1) < maze.length)
				if( (maze[Y.peek()+1][X.peek()] != '#') && (maze[Y.peek()+1][X.peek()] != '-') && (maze[Y.peek()+1][X.peek()] != '@') && (maze[Y.peek()+1][X.peek()] != '-')) {
					dir = dir + "S";
				}
			if( (Y.peek() - 1) >= 0)
				if( (maze[Y.peek()-1][X.peek()] != '#') && (maze[Y.peek()-1][X.peek()] != '-') && (maze[Y.peek()-1][X.peek()] != '@') && (maze[Y.peek()-1][X.peek()] != '-')) {
					dir = dir + "N";
				}
			if( (X.peek() + 1) < maze[0].length) 
				if( (maze[Y.peek()][X.peek()+1] != '#') && (maze[Y.peek()][X.peek()+1] != '-') && (maze[Y.peek()][X.peek()+1] != '@') && (maze[Y.peek()][X.peek()+1] != '-')) {
					dir = dir + "E";
				}
			if( (X.peek() - 1) >= 0)
				if( (maze[Y.peek()][X.peek()-1] != '#') && (maze[Y.peek()][X.peek()-1] != '-') && (maze[Y.peek()][X.peek()-1] != '@') && (maze[Y.peek()][X.peek()-1] != '-')) {
					dir = dir + "W";
				}


			//System.out.println(dir);
			if( dir.equals("")) {
				try {
				maze[Y.peek()][X.peek()] = '@';
				X.pop();
				Y.pop();
				maze[Y.peek()][X.peek()] = '-';
				}catch(Exception e) {
					blankScreen();
					System.out.println("This maze has no valid path");
					break;
				}
			} else {
				if( dir.contains("E")) {
					maze[Y.peek()][X.peek()] = '-';
					Y.push(Y.peek());
					X.push(X.peek()+1);
					dir = "";
				}
				if( dir.contains("N")) {
					maze[Y.peek()][X.peek()] = '-';
					Y.push(Y.peek()-1);
					X.push(X.peek());
					dir = "";
				}
				if( dir.contains("S")) {
					maze[Y.peek()][X.peek()] = '-';
					Y.push(Y.peek()+1);
					X.push(X.peek());
					dir = "";
				}
				if( dir.contains("W")) {
					maze[Y.peek()][X.peek()] = '-';
					Y.push(Y.peek());
					X.push(X.peek()-1);
					dir = "";
				}
			}
			int i = 0;
			int j = 0;

			while (i<maze.length) {
				j = 0;
				while (j<maze[0].length) {
					System.out.print(maze[i][j] + " ");
					j++;
				}
				System.out.println("");
				i++;
			}

			if(((maze[Y.peek()][X.peek()])==('*'))) {
				found = true;
				blankScreen();
				System.out.println("I found the exit");
				
				while (!X.isEmpty() && !Y.isEmpty()) {
					maze[Y.pop()][X.pop()] = '-';
				}
				clearFails(maze);
						}

			dir = "";
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
	
	public static void blankScreen() {
		for(int i=1; i<10; i++){
			System.out.println("\n\n\n\n\n\n\n\n");
		}
	}
	
	public static void clearFails(char[][] maze) {
		for(int q=0;q<maze.length-1;q++) {
			for(int p=0; p<maze[q].length;p++) {
				if(maze[q][p]=='@') {
					maze[q][p]='.';
			}
		}
	}
}}
